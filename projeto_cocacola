import gspread
from google.oauth2.service_account import Credentials
from datetime import datetime
import logging
import os
import traceback
import time
import numpy as np
import uuid
import serial
import threading
import re
import math
from dotenv import load_dotenv
import json
import signal
import sys

# Paths absolutos para SystemD
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
CREDENTIALS_PATH = os.path.join(SCRIPT_DIR, 'credenciais2.json')
ENV_FILE_PATH = os.path.join(SCRIPT_DIR, '.env')

# Configura√ß√£o b√°sica de logging
logging.basicConfig(
    level=logging.INFO,
    format='%(levelname)s - %(message)s',  # Formato simplificado para SystemD
    handlers=[logging.StreamHandler()]     # SystemD captura automaticamente
)
logger = logging.getLogger('radar_serial_app')

# Configurando o n√≠vel de log para outros m√≥dulos
logging.getLogger('urllib3').setLevel(logging.WARNING)
logging.getLogger('gspread').setLevel(logging.WARNING)

# Carregar vari√°veis de ambiente do diret√≥rio correto
load_dotenv(ENV_FILE_PATH)

SERIAL_CONFIG = {
    'baudrate': int(os.getenv('SERIAL_BAUDRATE', 115200))
}
RANGE_STEP = 2.5

# Configura√ß√£o para dois radares
RADAR_CONFIGS = [
    {
        'id': 'RADAR_1',
        'port': None,  # Ser√° detectada automaticamente
        'baudrate': int(os.getenv('SERIAL_BAUDRATE', 115200)),
        'description': 'Radar Principal',
        'spreadsheet_name': 'Projeto_cocacola',  # Planilha original
        'worksheet_name': 'Sheet1'
    },
    {
        'id': 'RADAR_2', 
        'port': None,  # Ser√° detectada automaticamente
        'baudrate': int(os.getenv('SERIAL_BAUDRATE', 115200)),
        'description': 'Radar Secund√°rio',
        'spreadsheet_name': '1hj1sbCDvHnwUeLbeACxoQvjEJJWxd8yFIaB3drsKMKE',  # Planilha do RADAR_2
        'worksheet_name': 'Sheet1'
    }
]

class GoogleSheetsManager:
    def __init__(self, creds_path, spreadsheet_name, worksheet_name='Sheet1'):
        SCOPES = [
            'https://www.googleapis.com/auth/spreadsheets',
            'https://www.googleapis.com/auth/drive.readonly'
        ]
        
        try:
            self.creds = Credentials.from_service_account_file(creds_path, scopes=SCOPES)
        except Exception as e:
            logger.error(f"‚ùå Erro ao carregar credenciais: {str(e)}")
            raise
        
        try:
            self.gc = gspread.authorize(self.creds)
        except Exception as e:
            logger.error(f"‚ùå Erro na autoriza√ß√£o: {str(e)}")
            raise
        
        try:
            self.spreadsheet = self.gc.open(spreadsheet_name)
        except Exception as e:
            logger.error(f"‚ùå Erro ao abrir planilha: {str(e)}")
            raise
        
        try:
            self.worksheet = self.spreadsheet.worksheet(worksheet_name)
            logger.info(f"‚úÖ Google Sheets conectado")
        except Exception as e:
            logger.error(f"‚ùå Erro ao acessar worksheet: {str(e)}")
            raise

    def insert_radar_data(self, data):
        try:
            row = [
                data.get('radar_id', 'N/A'),  # Identificador do radar
                data.get('session_id'),
                data.get('timestamp'),
                data.get('x_point'),
                data.get('y_point'),
                data.get('move_speed'),
                data.get('heart_rate'),
                data.get('breath_rate'),
                data.get('distance'),
                data.get('section_id'),
                data.get('product_id'),
                data.get('satisfaction_score'),
                data.get('satisfaction_class'),
                data.get('is_engaged')
            ]
            
            # Verificar se h√° valores None ou problem√°ticos
            problematic_values = []
            for i, value in enumerate(row):
                if value is None:
                    problematic_values.append(f"√≠ndice {i}: None")
                elif isinstance(value, (int, float)) and (value != value):  # NaN check
                    problematic_values.append(f"√≠ndice {i}: NaN")
                elif isinstance(value, str) and len(value) > 1000:  # String muito longa
                    problematic_values.append(f"√≠ndice {i}: string muito longa ({len(value)} chars)")
            
            if problematic_values:
                logger.warning(f"‚ö†Ô∏è [GSHEETS] Valores problem√°ticos encontrados: {problematic_values}")
            
            self.worksheet.append_row(row)
            
            logger.info('‚úÖ Dados enviados para o Google Sheets!')
            return True
            
        except Exception as e:
            logger.error(f'‚ùå [GSHEETS] Erro ao enviar dados para o Google Sheets: {str(e)}')
            logger.error(f'‚ùå [GSHEETS] Tipo do erro: {type(e)}')
            logger.error(f'‚ùå [GSHEETS] Dados que causaram o erro: {data}')
            
            # Verifica√ß√µes espec√≠ficas para erros comuns
            error_msg = str(e).lower()
            if 'quota' in error_msg or 'rate' in error_msg:
                logger.error(f'‚ùå [GSHEETS] Erro de limite de taxa da API! Aguarde antes de tentar novamente.')
                logger.error(f'‚ùå [GSHEETS] Considere adicionar delays entre as requisi√ß√µes.')
            elif 'permission' in error_msg or 'forbidden' in error_msg:
                logger.error(f'‚ùå [GSHEETS] Erro de permiss√£o! Verifique as credenciais e permiss√µes da planilha.')
            elif 'not found' in error_msg:
                logger.error(f'‚ùå [GSHEETS] Planilha ou worksheet n√£o encontrada! Verifique o nome da planilha.')
            elif 'authentication' in error_msg or 'auth' in error_msg:
                logger.error(f'‚ùå [GSHEETS] Erro de autentica√ß√£o! Verifique o arquivo de credenciais.')
            else:
                logger.error(f'‚ùå [GSHEETS] Erro desconhecido da API do Google Sheets.')
            
            logger.error(traceback.format_exc())
            return False

def parse_serial_data(raw_data):
    try:
        # Suporte para m√∫ltiplos formatos de dados do Arduino
        
        # FORMATO 1: Formato atual do radar (Human Detected + Target)
        # -----Human Detected-----
        # breath_rate: 30.00
        # heart_rate: 82.00
        # x_position: -0.15
        # y_position: 0.38
        # distance: -0.00
        # Target 1:
        #   x_point: -0.15
        #   y_point: 0.38
        #   dop_index: 0
        #   cluster_index: 0
        #   move_speed: 0.00 cm/s
        has_human_detected = '-----Human Detected-----' in raw_data
        has_target_1 = 'Target 1:' in raw_data
        
        if has_human_detected and has_target_1:
            logger.debug("üì° [PARSER] Detectado formato atual do radar (Human Detected + Target)")
            
            # Padr√µes regex para todos os campos solicitados
            x_position_pattern = r'x_position\s*:\s*([-+]?\d*\.?\d+)'
            y_position_pattern = r'y_position\s*:\s*([-+]?\d*\.?\d+)'
            x_point_pattern = r'x_point\s*:\s*([-+]?\d*\.?\d+)'
            y_point_pattern = r'y_point\s*:\s*([-+]?\d*\.?\d+)'
            breath_rate_pattern = r'breath_rate\s*:\s*([-+]?\d*\.?\d+)'
            heart_rate_pattern = r'heart_rate\s*:\s*([-+]?\d*\.?\d+)'
            distance_pattern = r'distance\s*:\s*([-+]?\d*\.?\d+)'
            move_speed_pattern = r'move_speed\s*:\s*([-+]?\d*\.?\d+)\s*cm/s'
            dop_index_pattern = r'dop_index\s*:\s*([-+]?\d+)'
            cluster_index_pattern = r'cluster_index\s*:\s*(\d+)'
            
            # Busca por todos os campos
            x_position_match = re.search(x_position_pattern, raw_data, re.IGNORECASE)
            y_position_match = re.search(y_position_pattern, raw_data, re.IGNORECASE)
            x_point_match = re.search(x_point_pattern, raw_data, re.IGNORECASE)
            y_point_match = re.search(y_point_pattern, raw_data, re.IGNORECASE)
            breath_rate_match = re.search(breath_rate_pattern, raw_data, re.IGNORECASE)
            heart_rate_match = re.search(heart_rate_pattern, raw_data, re.IGNORECASE)
            distance_match = re.search(distance_pattern, raw_data, re.IGNORECASE)
            move_speed_match = re.search(move_speed_pattern, raw_data, re.IGNORECASE)
            dop_index_match = re.search(dop_index_pattern, raw_data, re.IGNORECASE)
            cluster_index_match = re.search(cluster_index_pattern, raw_data, re.IGNORECASE)
            
            # Prioriza x_point/y_point se dispon√≠veis, sen√£o usa x_position/y_position
            x_coord = None
            y_coord = None
            
            if x_point_match and y_point_match:
                x_coord = float(x_point_match.group(1))
                y_coord = float(y_point_match.group(1))
                logger.debug(f"üì° [PARSER] Usando coordenadas do Target: x={x_coord}, y={y_coord}")
            elif x_position_match and y_position_match:
                x_coord = float(x_position_match.group(1))
                y_coord = float(y_position_match.group(1))
                logger.debug(f"üì° [PARSER] Usando coordenadas de posi√ß√£o: x={x_coord}, y={y_coord}")
            
            if x_coord is not None and y_coord is not None:
                # Extrai velocidade (move_speed em cm/s, converte para m/s)
                move_speed = 0.0
                if move_speed_match:
                    move_speed = float(move_speed_match.group(1)) / 100.0  # cm/s para m/s
                    logger.debug(f"üì° [PARSER] Velocidade detectada: {move_speed} m/s")
                
                # Extrai dados vitais
                breath_rate = 15.0  # Valor padr√£o
                if breath_rate_match:
                    breath_rate = float(breath_rate_match.group(1))
                    logger.debug(f"üì° [PARSER] Taxa de respira√ß√£o: {breath_rate}")
                
                heart_rate = 75.0  # Valor padr√£o
                if heart_rate_match:
                    heart_rate = float(heart_rate_match.group(1))
                    logger.debug(f"üì° [PARSER] Frequ√™ncia card√≠aca: {heart_rate}")
                
                # Extrai dist√¢ncia
                distance = None
                if distance_match:
                    distance = float(distance_match.group(1))
                    logger.debug(f"üì° [PARSER] Dist√¢ncia: {distance}")
                
                # Calcula dist√¢ncia se n√£o fornecida ou se for inv√°lida
                if distance is None or distance <= 0:
                    distance = math.sqrt(x_coord**2 + y_coord**2)
                    logger.debug(f"üì° [PARSER] Dist√¢ncia calculada: {distance}")
                
                # Extrai √≠ndices
                dop_index = int(dop_index_match.group(1)) if dop_index_match else 0
                cluster_index = int(cluster_index_match.group(1)) if cluster_index_match else 0
                
                data = {
                    'x_point': x_coord,
                    'y_point': y_coord,
                    'breath_rate': breath_rate,
                    'heart_rate': heart_rate,
                    'distance': distance,
                    'move_speed': move_speed,
                    'dop_index': dop_index,
                    'cluster_index': cluster_index,
                    'total_phase': 0.0,  # N√£o dispon√≠vel no formato atual
                    'breath_phase': 0.0,  # N√£o dispon√≠vel no formato atual
                    'heart_phase': 0.0    # N√£o dispon√≠vel no formato atual
                }
                
                logger.info(f"‚úÖ [PARSER] Dados parseados: X={x_coord:.2f}m, Y={y_coord:.2f}m, ‚ù§Ô∏è{heart_rate:.0f}, ü´Å{breath_rate:.0f}, üèÉ{move_speed:.2f}m/s")
                return data
        
        # FORMATO 2: Formato simples (send_formatted_data)
        # breath_rate: 15.00
        # heart_rate: 75.00  
        # x_position: 0.50
        # y_position: 1.20
        if 'breath_rate:' in raw_data and 'x_position:' in raw_data:
            logger.debug("üì° [PARSER] Detectado formato simples do Arduino")
            
            breath_rate_match = re.search(r'breath_rate\s*:\s*([-+]?\d*\.?\d+)', raw_data, re.IGNORECASE)
            heart_rate_match = re.search(r'heart_rate\s*:\s*([-+]?\d*\.?\d+)', raw_data, re.IGNORECASE)
            x_position_match = re.search(r'x_position\s*:\s*([-+]?\d*\.?\d+)', raw_data, re.IGNORECASE)
            y_position_match = re.search(r'y_position\s*:\s*([-+]?\d*\.?\d+)', raw_data, re.IGNORECASE)
            
            if x_position_match and y_position_match:
                data = {
                    'x_point': float(x_position_match.group(1)),
                    'y_point': float(y_position_match.group(1)),
                    'breath_rate': float(breath_rate_match.group(1)) if breath_rate_match else 15.0,
                    'heart_rate': float(heart_rate_match.group(1)) if heart_rate_match else 75.0,
                    'distance': math.sqrt(float(x_position_match.group(1))**2 + float(y_position_match.group(1))**2),
                    'move_speed': 0.0,
                    'dop_index': 0,
                    'cluster_index': 0,
                    'total_phase': 0.0,
                    'breath_phase': 0.0,
                    'heart_phase': 0.0
                }
                return data
        
        # FORMATO 3: Mensagens do sistema (n√£o processa dados, s√≥ registra)
        if any(msg in raw_data for msg in ['HEARTBEAT:', 'DEEP SLEEP', 'Acordou', 'Sistema ativo']):
            logger.debug(f"üì° [PARSER] Mensagem do sistema: {raw_data.strip()}")
            return None
            
        # Se nenhum formato foi reconhecido
        logger.warning(f"‚ö†Ô∏è [PARSER] Formato n√£o reconhecido: {raw_data[:100]}...")
        return None
        
    except Exception as e:
        logger.error(f"‚ùå Erro ao analisar dados seriais: {str(e)}")
        logger.error(traceback.format_exc())
        return None

def convert_radar_data(raw_data):
    """Converte dados brutos do radar para o formato do banco de dados"""
    try:
        # Verificar se j√° √© um dicion√°rio
        if isinstance(raw_data, dict):
            data = raw_data
        else:
            # Tentar parsear como JSON primeiro
            try:
                data = json.loads(raw_data)
            except:
                # Se n√£o for JSON, tentar parsear como texto da serial
                data = parse_serial_data(raw_data)
                if not data:
                    return None

        # Garantir que todos os campos necess√°rios est√£o presentes
        result = {
            'x_point': float(data.get('x_point', 0)),
            'y_point': float(data.get('y_point', 0)),
            'move_speed': float(data.get('move_speed', 0)),
            'heart_rate': float(data.get('heart_rate', 75)),
            'breath_rate': float(data.get('breath_rate', 15))
        }

        return result
    except Exception as e:
        logger.error(f"Erro ao converter dados do radar: {str(e)}")
        logger.error(traceback.format_exc())
        return None

class ShelfManager:
    def __init__(self):
        self.SECTION_WIDTH = 0.5  # metros
        self.SECTION_HEIGHT = 0.3  # metros
        self.MAX_SECTIONS_X = 3
        self.MAX_SECTIONS_Y = 1
        self.SCALE_FACTOR = 1  # N√£o precisa mais de escala
        self.sections = [
            {
                'section_id': 1,
                'section_name': 'Se√ß√£o 1',
                'product_id': '1',
                'x_start': 0.0,
                'y_start': 0.0,
                'x_end': 0.5,
                'y_end': 1.5
            },
            {
                'section_id': 2,
                'section_name': 'Se√ß√£o 2',
                'product_id': '2',
                'x_start': 0.5,
                'y_start': 0.0,
                'x_end': 1.0,
                'y_end': 1.5
            },
            {
                'section_id': 3,
                'section_name': 'Se√ß√£o 3',
                'product_id': '3',
                'x_start': 1.0,
                'y_start': 0.0,
                'x_end': 1.5,
                'y_end': 1.5
            }
        ]

    def get_section_at_position(self, x, y, db_manager=None):
        if x < -1.0 or x > 1.0 or y < 0 or y > 1.5:
            return None
        for section in self.sections:
            if (section['x_start'] <= x <= section['x_end'] and section['y_start'] <= y <= section['y_end']):
                return section
        return None

shelf_manager = ShelfManager()

class AnalyticsManager:
    def __init__(self):
        self.MOVEMENT_THRESHOLD = 20.0  # cm/s
        self.DISTANCE_THRESHOLD = 2.0   # metros
        self.HEART_RATE_NORMAL = (60, 100)  # bpm
        self.BREATH_RATE_NORMAL = (12, 20)  # rpm

    def calculate_satisfaction_score(self, move_speed, heart_rate, breath_rate, distance):
        try:
            # Considera NEUTRA se algum valor for None ou 0 (aus√™ncia de leitura)
            if heart_rate is None or breath_rate is None or heart_rate == 0 or breath_rate == 0:
                return (60.0, "NEUTRA")

            # MUITO_POSITIVA
            if (65 <= heart_rate <= 90 and 13 <= breath_rate <= 18 and move_speed < 6):
                return (95.0, "MUITO_POSITIVA")
            # POSITIVA
            elif (60 <= heart_rate <= 100 and 12 <= breath_rate <= 20 and move_speed < 12):
                return (80.0, "POSITIVA")
            # NEUTRA
            elif (55 <= heart_rate <= 110 and 10 <= breath_rate <= 22 and move_speed < 25):
                return (60.0, "NEUTRA")
            # NEGATIVA
            else:
                return (20.0, "NEGATIVA")
        except Exception as e:
            logger.error(f"Erro ao calcular satisfa√ß√£o: {str(e)}")
            return (60.0, "NEUTRA")

class VitalSignsManager:
    def __init__(self):
        self.SAMPLE_RATE = 20
        # Inicializa buffers com tamanho m√°ximo para evitar crescimento indefinido
        self.HEART_BUFFER_SIZE = 20
        self.BREATH_BUFFER_SIZE = 30
        self.QUALITY_BUFFER_SIZE = 10
        self.HISTORY_SIZE = 10
        
        # Inicializa buffers com tamanho m√°ximo
        self.heart_phase_buffer = [0.0] * self.HEART_BUFFER_SIZE
        self.breath_phase_buffer = [0.0] * self.BREATH_BUFFER_SIZE
        self.quality_buffer = [0.0] * self.QUALITY_BUFFER_SIZE
        self.heart_rate_history = [0.0] * self.HISTORY_SIZE
        self.breath_rate_history = [0.0] * self.HISTORY_SIZE
        
        # Contadores para controle de buffer circular
        self.heart_buffer_index = 0
        self.breath_buffer_index = 0
        self.quality_buffer_index = 0
        self.heart_history_index = 0
        self.breath_history_index = 0
        
        self.last_heart_rate = None
        self.last_breath_rate = None
        self.last_quality_score = 0
        self.MIN_QUALITY_SCORE = 0.3
        self.STABILITY_THRESHOLD = 0.4
        self.VALID_RANGES = {
            'heart_rate': (40, 140),
            'breath_rate': (8, 25)
        }

    def calculate_signal_quality(self, phase_data, distance):
        try:
            if not phase_data or len(phase_data) < 1:
                return 0.0
                
            # Se for um √∫nico valor, criar uma lista com ele
            if isinstance(phase_data, (int, float)):
                phase_data = [phase_data]
                
            distance_score = 1.0
            if distance < 30 or distance > 150:
                distance_score = 0.0
            elif distance > 100:
                distance_score = 1.0 - ((distance - 100) / 50)
                
            # Para um √∫nico valor, usar uma vari√¢ncia m√≠nima
            variance = 0.1 if len(phase_data) == 1 else np.var(phase_data)
            variance_score = 1.0 / (1.0 + variance * 10)
            
            # Para um √∫nico valor, usar uma amplitude m√≠nima
            amplitude = 0.1 if len(phase_data) == 1 else np.ptp(phase_data)
            amplitude_score = 1.0
            if amplitude < 0.01 or amplitude > 1.0:
                amplitude_score = 0.5
                
            quality_score = (distance_score * 0.3 +
                           variance_score * 0.4 +
                           amplitude_score * 0.3)
                           
            # Buffer circular para qualidade
            self.quality_buffer[self.quality_buffer_index] = quality_score
            self.quality_buffer_index = (self.quality_buffer_index + 1) % self.QUALITY_BUFFER_SIZE
                
            self.last_quality_score = np.mean(self.quality_buffer)
            return self.last_quality_score
            
        except Exception as e:
            logger.error(f"Erro ao calcular qualidade do sinal: {str(e)}")
            return 0.0

    def calculate_vital_signs(self, total_phase, breath_phase, heart_phase, distance):
        try:
            # Converter os valores de fase para listas se forem floats
            if isinstance(heart_phase, (int, float)):
                heart_phase = [heart_phase]
            if isinstance(breath_phase, (int, float)):
                breath_phase = [breath_phase]
                
            quality_score = self.calculate_signal_quality(heart_phase, distance)
            if quality_score < self.MIN_QUALITY_SCORE:
                return None, None
            # Buffer circular para fases
            self.heart_phase_buffer[self.heart_buffer_index] = heart_phase
            self.breath_phase_buffer[self.breath_buffer_index] = breath_phase
            
            self.heart_buffer_index = (self.heart_buffer_index + 1) % self.HEART_BUFFER_SIZE
            self.breath_buffer_index = (self.breath_buffer_index + 1) % self.BREATH_BUFFER_SIZE
            
            # Verifica se temos dados suficientes (70% do buffer preenchido)
            heart_data_count = min(self.heart_buffer_index, self.HEART_BUFFER_SIZE)
            if heart_data_count < self.HEART_BUFFER_SIZE * 0.7:
                return None, None
            heart_weights = np.hamming(len(self.heart_phase_buffer))
            breath_weights = np.hamming(len(self.breath_phase_buffer))
            heart_smooth = np.average(self.heart_phase_buffer, weights=heart_weights)
            breath_smooth = np.average(self.breath_phase_buffer, weights=breath_weights)
            heart_rate = self._calculate_rate_from_phase(
                self.heart_phase_buffer,
                min_freq=self.VALID_RANGES['heart_rate'][0]/60,
                max_freq=self.VALID_RANGES['heart_rate'][1]/60,
                rate_multiplier=60
            )
            breath_rate = self._calculate_rate_from_phase(
                self.breath_phase_buffer,
                min_freq=self.VALID_RANGES['breath_rate'][0]/60,
                max_freq=self.VALID_RANGES['breath_rate'][1]/60,
                rate_multiplier=60
            )
            if heart_rate:
                if self.last_heart_rate:
                    rate_change = abs(heart_rate - self.last_heart_rate) / self.last_heart_rate
                    if rate_change > self.STABILITY_THRESHOLD:
                        heart_rate = (heart_rate + self.last_heart_rate) / 2
                    else:
                        self.last_heart_rate = heart_rate
                else:
                    self.last_heart_rate = heart_rate
                # Buffer circular para hist√≥rico de batimentos
                self.heart_rate_history[self.heart_history_index] = heart_rate
                self.heart_history_index = (self.heart_history_index + 1) % self.HISTORY_SIZE
            if breath_rate:
                if self.last_breath_rate:
                    rate_change = abs(breath_rate - self.last_breath_rate) / self.last_breath_rate
                    if rate_change > self.STABILITY_THRESHOLD:
                        breath_rate = None
                    else:
                        self.last_breath_rate = breath_rate
                else:
                    self.last_breath_rate = breath_rate
                # Buffer circular para hist√≥rico de respira√ß√£o
                self.breath_rate_history[self.breath_history_index] = breath_rate
                self.breath_history_index = (self.breath_history_index + 1) % self.HISTORY_SIZE
            return heart_rate, breath_rate
        except Exception as e:
            logger.error(f"Erro ao calcular sinais vitais: {str(e)}")
            logger.error(traceback.format_exc())
            return None, None

    def _calculate_rate_from_phase(self, phase_data, min_freq, max_freq, rate_multiplier):
        try:
            if not phase_data:
                return None
            
            # Filtra dados v√°lidos (remove zeros)
            valid_data = [x for x in phase_data if x != 0.0]
            if len(valid_data) < 3:  # M√≠nimo de dados para FFT
                return None
                
            phase_mean = np.mean(valid_data)
            centered_phase = np.array(valid_data) - phase_mean
            
            # Aplica janela de Hamming para melhorar FFT
            window = np.hanning(len(centered_phase))
            windowed_phase = centered_phase * window
            
            # FFT otimizada - s√≥ calcula se necess√°rio
            fft_result = np.fft.fft(windowed_phase)
            fft_freq = np.fft.fftfreq(len(windowed_phase), d=1/self.SAMPLE_RATE)
            
            # Filtra frequ√™ncias v√°lidas
            valid_idx = np.where((fft_freq >= min_freq) & (fft_freq <= max_freq))[0]
            if len(valid_idx) == 0:
                return None
                
            magnitude_spectrum = np.abs(fft_result[valid_idx])
            peak_idx = np.argmax(magnitude_spectrum)
            dominant_freq = fft_freq[valid_idx[peak_idx]]
            peak_magnitude = magnitude_spectrum[peak_idx]
            avg_magnitude = np.mean(magnitude_spectrum)
            
            # Verifica se o pico √© significativo
            if peak_magnitude < 1.5 * avg_magnitude:
                return None
                
            rate = abs(dominant_freq * rate_multiplier)
            return round(rate, 1)
            
        except Exception as e:
            logger.error(f"Erro ao calcular taxa a partir da fase: {str(e)}")
            return None

# Remover importa√ß√£o da EmotionalStateAnalyzer e campos emocionais
class DualRadarManager:
    def __init__(self, radar_configs):
        self.radar_configs = radar_configs
        self.radar_connections = {}  # Dicion√°rio para armazenar conex√µes de cada radar
        self.is_running = False
        self.receive_threads = {}  # Threads para cada radar
        self.db_manager = None
        self.analytics_manager = AnalyticsManager()
        self.vital_signs_manager = VitalSignsManager()
        
        # Sess√µes separadas para cada radar
        self.current_session_ids = {}
        self.last_activity_times = {}
        self.session_positions = {}
        
        # Configura√ß√µes de sess√£o
        self.SESSION_TIMEOUT = 60  # 1 minuto para identificar novas pessoas
        self.last_valid_data_times = {}
        self.RESET_TIMEOUT = 60  # 1 minuto
        
        # Contadores para debug
        self.messages_received = {}
        self.messages_processed = {}
        self.messages_failed = {}
        
        # Sistema de retry para reconex√µes
        self.consecutive_errors = {}
        self.MAX_CONSECUTIVE_ERRORS = 5
        self.last_error_times = {}
        
        # Inicializa estruturas para cada radar
        for config in radar_configs:
            radar_id = config['id']
            self.current_session_ids[radar_id] = None
            self.last_activity_times[radar_id] = None
            self.session_positions[radar_id] = []
            self.last_valid_data_times[radar_id] = time.time()
            self.messages_received[radar_id] = 0
            self.messages_processed[radar_id] = 0
            self.messages_failed[radar_id] = 0
            self.consecutive_errors[radar_id] = 0
            self.last_error_times[radar_id] = 0

    def _generate_session_id(self, radar_id):
        """Gera um novo ID de sess√£o para um radar espec√≠fico"""
        return f"{radar_id}_{str(uuid.uuid4())}"

    def _check_session_timeout(self, radar_id):
        """Verifica se a sess√£o atual de um radar expirou"""
        if (self.last_activity_times[radar_id] and 
            (time.time() - self.last_activity_times[radar_id]) > self.SESSION_TIMEOUT):
            logger.debug(f"Sess√£o expirada para {radar_id}, gerando nova sess√£o")
            self.current_session_ids[radar_id] = self._generate_session_id(radar_id)
            self.last_activity_times[radar_id] = time.time()
            self.session_positions[radar_id] = []
            return True
        return False

    def _is_new_person(self, radar_id, x, y, move_speed):
        """Verifica se os dados indicam uma nova pessoa para um radar espec√≠fico"""
        last_position = getattr(self, 'last_positions', {}).get(radar_id)
        if not last_position:
            return True

        last_x, last_y = last_position
        distance = math.sqrt((x - last_x)**2 + (y - last_y)**2)
        
        # Se a dist√¢ncia for muito grande ou a velocidade for muito alta, provavelmente √© uma nova pessoa
        if distance > 0.5 or move_speed > 20.0:
            return True
            
        # Verifica se o movimento √© consistente com a √∫ltima posi√ß√£o
        if len(self.session_positions[radar_id]) >= 2:
            last_positions = self.session_positions[radar_id][-2:]
            avg_speed = sum(p['speed'] for p in last_positions) / len(last_positions)
            if abs(move_speed - avg_speed) > 20.0:
                return True
                
        return False

    def _update_session(self, radar_id):
        """Atualiza ou cria uma nova sess√£o para um radar espec√≠fico"""
        current_time = time.time()
        
        # Verifica timeout da sess√£o
        if (not self.current_session_ids[radar_id] or 
            self._check_session_timeout(radar_id)):
            self.current_session_ids[radar_id] = self._generate_session_id(radar_id)
            self.last_activity_times[radar_id] = current_time
            self.session_positions[radar_id] = []
            logger.debug(f"Nova sess√£o iniciada para {radar_id}: {self.current_session_ids[radar_id]}")
        else:
            self.last_activity_times[radar_id] = current_time

    def find_serial_ports(self):
        """Detecta automaticamente portas seriais dispon√≠veis para ambos os radares"""
        try:
            import serial.tools.list_ports
            
            logger.info("üîç Buscando portas seriais dispon√≠veis para dois radares...")
            ports = list(serial.tools.list_ports.comports())
            
            if not ports:
                logger.error("‚ùå Nenhuma porta serial encontrada!")
                return False
            
            logger.info(f"üìã {len(ports)} porta(s) encontrada(s):")
            
            # Lista todas as portas para debug
            for i, port in enumerate(ports):
                logger.info(f"   {i+1}. {port.device}")
                logger.info(f"      Descri√ß√£o: {port.description}")
                if hasattr(port, 'manufacturer') and port.manufacturer:
                    logger.info(f"      Fabricante: {port.manufacturer}")
            
            # Filtra portas v√°lidas (exclui Bluetooth e debug console)
            valid_ports = []
            for port in ports:
                device_lower = str(port.device).lower()
                desc_lower = str(port.description).lower()
                
                # Evita portas Bluetooth e debug console
                if not any(skip in device_lower or skip in desc_lower for skip in 
                          ['bluetooth', 'debug-console', 'incoming-port']):
                    valid_ports.append(port)
            
            if len(valid_ports) < 2:
                logger.error(f"‚ùå Apenas {len(valid_ports)} porta(s) v√°lida(s) encontrada(s). S√£o necess√°rias 2 portas para dois radares.")
                return False
            
            # Atribui portas aos radares
            for i, config in enumerate(self.radar_configs):
                if i < len(valid_ports):
                    config['port'] = valid_ports[i].device
                    logger.info(f"‚úÖ {config['id']} ({config['description']}) atribu√≠do √† porta: {config['port']}")
                else:
                    logger.error(f"‚ùå N√£o h√° portas suficientes para {config['id']}")
                    return False
            
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Erro na detec√ß√£o de portas: {str(e)}")
            return False

    def connect_radar(self, radar_id):
        """Conecta a um radar espec√≠fico"""
        config = next((c for c in self.radar_configs if c['id'] == radar_id), None)
        if not config:
            logger.error(f"‚ùå Configura√ß√£o n√£o encontrada para {radar_id}")
            return False
        
        try:
            logger.info(f"üîÑ Conectando {radar_id} √† porta {config['port']} (baudrate: {config['baudrate']})...")
            
            serial_connection = serial.Serial(
                port=config['port'],
                baudrate=config['baudrate'],
                timeout=1,
                write_timeout=1,
                bytesize=serial.EIGHTBITS,
                parity=serial.PARITY_NONE,
                stopbits=serial.STOPBITS_ONE
            )
            
            time.sleep(2)
            
            self.radar_connections[radar_id] = serial_connection
            logger.info(f"‚úÖ {radar_id} conectado com sucesso!")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao conectar {radar_id}: {str(e)}")
            logger.error(traceback.format_exc())
            return False

    def connect_all_radars(self):
        """Conecta a todos os radares"""
        if not self.find_serial_ports():
            return False
        
        success_count = 0
        for config in self.radar_configs:
            if self.connect_radar(config['id']):
                success_count += 1
        
        if success_count == len(self.radar_configs):
            logger.info(f"‚úÖ Todos os {success_count} radares conectados com sucesso!")
            return True
        else:
            logger.error(f"‚ùå Apenas {success_count}/{len(self.radar_configs)} radares conectados!")
            return False

    def start(self, db_manager=None):
        """Inicia o sistema de radar dual para SystemD"""
        self.db_manager = db_manager
        self.is_running = True
        
        # Cria gerenciadores do Google Sheets para cada radar
        self.gsheets_managers = {}
        for config in self.radar_configs:
            try:
                radar_id = config['id']
                spreadsheet_name = config['spreadsheet_name']
                worksheet_name = config.get('worksheet_name', 'Sheet1')
                
                logger.info(f"üîÑ Conectando {radar_id} ao Google Sheets: {spreadsheet_name}")
                gsheets_manager = GoogleSheetsManager(CREDENTIALS_PATH, spreadsheet_name, worksheet_name)
                self.gsheets_managers[radar_id] = gsheets_manager
                logger.info(f"‚úÖ {radar_id} conectado ao Google Sheets")
                
            except Exception as e:
                logger.error(f"‚ùå Erro ao conectar {radar_id} ao Google Sheets: {str(e)}")
                return False
        
        try:
            # Conecta a todos os radares
            if not self.connect_all_radars():
                logger.error("‚ùå Falha ao conectar com os radares")
                return False
            
            # Configura√ß√£o inicial dos sensores
            for config in self.radar_configs:
                radar_id = config['id']
                self.configure_sensor_continuous_mode(radar_id)
                time.sleep(1)
            
            # Inicia threads de recep√ß√£o para cada radar
            for config in self.radar_configs:
                radar_id = config['id']
                self.receive_threads[radar_id] = threading.Thread(
                    target=self.receive_data_loop, 
                    args=(radar_id,), 
                    daemon=True
                )
                self.receive_threads[radar_id].start()
                logger.info(f"‚úÖ Thread iniciada para {radar_id}")
            
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao iniciar sistema dual: {str(e)}")
            return False

    def stop(self):
        """Para o sistema de radar dual para SystemD"""
        self.is_running = False
        
        # Para threads de recep√ß√£o
        for radar_id, thread in self.receive_threads.items():
            if thread and thread.is_alive():
                thread.join(timeout=2)
        
        # Fecha conex√µes seriais
        for radar_id, connection in self.radar_connections.items():
            if connection and connection.is_open:
                connection.close()
        
        logger.info("‚úÖ Sistema de radar dual parado!")

    def hardware_reset_radar(self, radar_id):
        """Reinicia um radar espec√≠fico via DTR/RTS"""
        try:
            logger.warning(f"[RESET] Iniciando reset de {radar_id} via DTR/RTS...")
            
            connection = self.radar_connections.get(radar_id)
            if connection and connection.is_open:
                connection.close()
                
            # Reabre conex√£o para reset
            config = next((c for c in self.radar_configs if c['id'] == radar_id), None)
            if config:
                with serial.Serial(config['port'], config['baudrate'], timeout=1) as ser:
                    ser.setDTR(False)
                    ser.setRTS(True)
                    time.sleep(0.1)
                    ser.setDTR(True)
                    ser.setRTS(False)
                    time.sleep(0.1)
                    
                    ser.setDTR(False)
                    time.sleep(0.1)
                    ser.setDTR(True)
                    time.sleep(0.5)
                
                logger.info(f"[RESET] {radar_id} resetado com sucesso!")
                
                # Reconecta
                time.sleep(3)
                self.connect_radar(radar_id)
                return True
                
        except Exception as e:
            logger.error(f"[RESET] Falha ao resetar {radar_id}: {e}")
            return False

    def receive_data_loop(self, radar_id):
        """Loop de recep√ß√£o de dados para um radar espec√≠fico"""
        buffer = ""
        last_data_time = time.time()
        
        while self.is_running:
            try:
                connection = self.radar_connections.get(radar_id)
                if not connection or not connection.is_open:
                    logger.warning(f"‚ö†Ô∏è Conex√£o de {radar_id} fechada, tentando reconectar...")
                    self.connect_radar(radar_id)
                    time.sleep(1)
                    continue

                in_waiting = connection.in_waiting
                if in_waiting is None:
                    in_waiting = 0

                data = connection.read(in_waiting or 1)
                if data:
                    last_data_time = time.time()
                    text = data.decode('utf-8', errors='ignore')
                    buffer += text

                    while '\n' in buffer:
                        line, buffer = buffer.split('\n', 1)
                        line = line.strip('\r')
                        
                        if line.strip():
                            # Processa dados do radar
                            if any(key in line for key in ['breath_rate', 'heart_rate', 'x_position', 'y_position', 'Human Detected', 'Target']):
                                logger.debug(f"üéØ [{radar_id}] Dados: {line.strip()}")
                                self.process_radar_data(radar_id, line.strip())
                                self.last_valid_data_times[radar_id] = time.time()
                            # Logs de sistema
                            elif any(critical in line for critical in ['CR√çTICO', 'FALHOU', 'ERROR', '‚ùå']):
                                logger.warning(f"‚ö†Ô∏è [{radar_id}] {line.strip()}")
                            else:
                                logger.debug(f"Debug [{radar_id}]: {line.strip()}")
                        
                        # Processa blocos de dados
                        if '-----Human Detected-----' in line:
                            # Inicia coleta de bloco
                            bloco_buffer = line + "\n"
                            while '\n' in buffer:
                                line, buffer = buffer.split('\n', 1)
                                line = line.strip('\r')
                                if line.strip() == "":
                                    # Fim do bloco
                                    self.process_radar_data(radar_id, bloco_buffer)
                                    self.last_valid_data_times[radar_id] = time.time()
                                    break
                                else:
                                    bloco_buffer += line + "\n"
                            continue

                # Verifica timeout de dados
                current_time = time.time()
                if current_time - self.last_valid_data_times[radar_id] > self.RESET_TIMEOUT:
                    logger.warning(f"‚ö†Ô∏è {radar_id}: Nenhum dado recebido por mais de 10 minutos. Executando reset...")
                    self.hardware_reset_radar(radar_id)
                    self.last_valid_data_times[radar_id] = current_time

                if time.time() - last_data_time > 30:
                    logger.warning(f"‚ö†Ô∏è {radar_id}: Nenhum dado recebido nos √∫ltimos 30 segundos")
                    last_data_time = time.time()

                time.sleep(0.01)
                
            except Exception as e:
                logger.error(f"‚ùå [{radar_id}] Erro no loop de recep√ß√£o: {str(e)}")
                time.sleep(1)

    def configure_sensor_continuous_mode(self, radar_id):
        """Configura sensor para modo cont√≠nuo - Adaptado para novo Arduino"""
        try:
            connection = self.radar_connections.get(radar_id)
            if connection and connection.is_open:
                logger.info(f"[CONFIG] Configurando {radar_id} para modo cont√≠nuo...")
                
                # Comandos para modo cont√≠nuo via Tiny Frame
                continuous_mode_frame = bytes([0x02, 0x01, 0x02, 0x01, 0x06])
                connection.write(continuous_mode_frame)
                time.sleep(0.5)
                
                # Comando para desabilitar sleep
                sleep_disable_frame = bytes([0x02, 0x01, 0x03, 0x00, 0x06])
                connection.write(sleep_disable_frame)
                time.sleep(0.5)
                
                # Comando para modo sempre ativo
                always_on_frame = bytes([0x02, 0x01, 0x04, 0x01, 0x08])
                connection.write(always_on_frame)
                time.sleep(0.5)
                
                # Comandos ASCII compat√≠veis
                ascii_commands = [
                    "CONTINUOUS_MODE=1",
                    "SLEEP_MODE=0", 
                    "ALWAYS_ON=1",
                    "TIMEOUT=0",
                    "CONTINUOUS_DETECTION=1",
                    "POSITION_MODE=1",
                    "TARGET_TRACKING=1"
                ]
                
                for cmd in ascii_commands:
                    connection.write(f"{cmd}\n".encode())
                    time.sleep(0.2)
                
                logger.info(f"‚úÖ {radar_id} configurado para modo cont√≠nuo")
                return True
                
        except Exception as e:
            logger.error(f"‚ùå [CONFIG] Erro ao configurar {radar_id}: {str(e)}")
            return False

    def process_radar_data(self, radar_id, raw_data):
        """Processa dados de um radar espec√≠fico"""
        # Usa o parser atualizado que suporta m√∫ltiplos formatos
        data = parse_serial_data(raw_data)
        
        if data is None:
            logger.warning(f"‚ùå [{radar_id}] Parser retornou None para: {raw_data[:200]}...")
            return
            
        # Marca como dados reais e adiciona identificador do radar
        data['is_simulated'] = False
        data['radar_id'] = radar_id
        
        self.messages_processed[radar_id] += 1
        
        # Log conciso para SystemD
        logger.info(f"‚úÖ [{radar_id}] Cliente: x={data.get('x_point', 0):.1f}m y={data.get('y_point', 0):.1f}m ‚ù§Ô∏è{data.get('heart_rate', 0):.0f} ü´Å{data.get('breath_rate', 0):.0f}")
        
        x = data.get('x_point', 0)
        y = data.get('y_point', 0)
        move_speed = abs(data.get('dop_index', 0) * RANGE_STEP) if 'dop_index' in data else data.get('move_speed', 0)
        
        if self._is_new_person(radar_id, x, y, move_speed):
            self.current_session_ids[radar_id] = self._generate_session_id(radar_id)
            self.last_activity_times[radar_id] = time.time()
            self.session_positions[radar_id] = []
        
        # Atualiza posi√ß√£o para este radar
        if not hasattr(self, 'last_positions'):
            self.last_positions = {}
        self.last_positions[radar_id] = (x, y)
        
        # Buffer circular para posi√ß√µes de sess√£o
        if len(self.session_positions[radar_id]) >= 10:
            self.session_positions[radar_id].pop(0)
        
        self.session_positions[radar_id].append({
            'x': x,
            'y': y,
            'speed': move_speed,
            'timestamp': time.time()
        })
        
        self._update_session(radar_id)
        
        heart_rate = data.get('heart_rate')
        breath_rate = data.get('breath_rate')
        
        if heart_rate is None or breath_rate is None:
            heart_rate, breath_rate = self.vital_signs_manager.calculate_vital_signs(
                data.get('total_phase', 0),
                data.get('breath_phase', 0),
                data.get('heart_phase', 0),
                data.get('distance', 0)
            )
        
        distance = data.get('distance', 0)
        if distance == 0:
            x = data.get('x_point', 0)
            y = data.get('y_point', 0)
            distance = (x**2 + y**2)**0.5
        
        dop_index = data.get('dop_index', 0) if 'dop_index' in data else 0
        move_speed = abs(dop_index * RANGE_STEP) if dop_index is not None else data.get('move_speed', 0)
        
        converted_data = {
            'session_id': self.current_session_ids[radar_id],
            'radar_id': radar_id,  # Identificador do radar
            'x_point': data.get('x_point', 0),
            'y_point': data.get('y_point', 0),
            'move_speed': move_speed,
            'distance': distance,
            'dop_index': dop_index,
            'heart_rate': heart_rate,
            'breath_rate': breath_rate,
            'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            'is_simulated': data.get('is_simulated', False)
        }
        
        section = shelf_manager.get_section_at_position(
            converted_data['x_point'],
            converted_data['y_point'],
            self.db_manager
        )
        
        if section:
            converted_data['section_id'] = section['section_id']
            converted_data['product_id'] = section['product_id']
            
            # Calcula satisfa√ß√£o apenas se tiver dados vitais
            if heart_rate is not None and breath_rate is not None:
                satisfaction_result = self.analytics_manager.calculate_satisfaction_score(
                    move_speed, heart_rate, breath_rate, distance
                )
                satisfaction_score, satisfaction_class = satisfaction_result
                converted_data['satisfaction_score'] = satisfaction_score
                converted_data['satisfaction_class'] = satisfaction_class
                
                # Log simplificado para SystemD
                emoji_map = {
                    "MUITO_POSITIVA": "üòç",
                    "POSITIVA": "üòä", 
                    "NEUTRA": "üòê",
                    "NEGATIVA": "üòû",
                    "MUITO_NEGATIVA": "üò°"
                }
                emoji = emoji_map.get(satisfaction_class, "‚ùì")
                
                logger.info(f"üìä [{radar_id}] An√°lise: {emoji} {satisfaction_class} ({satisfaction_score:.0f}/100) | Dist: {distance:.1f}m | Vel: {move_speed:.0f}cm/s")
                
                if section:
                    logger.info(f"üè™ [{radar_id}] {section.get('section_name', 'N/A')} | üì¶ {section.get('product_id', 'N/A')}")
            else:
                converted_data['satisfaction_score'] = None
                converted_data['satisfaction_class'] = None
                logger.info(f"‚ö†Ô∏è [{radar_id}] Dados vitais insuficientes para an√°lise de satisfa√ß√£o")
            
            # Verifica engajamento
            converted_data['is_engaged'] = self._check_engagement(
                section['section_id'], distance, move_speed
            )
        else:
            converted_data['section_id'] = None
            converted_data['product_id'] = None
            converted_data['satisfaction_score'] = None
            converted_data['satisfaction_class'] = None
            converted_data['is_engaged'] = False
        
        # Envia para Google Sheets usando o gerenciador correto para este radar
        try:
            gsheets_manager = self.gsheets_managers.get(radar_id)
            if gsheets_manager:
                gsheets_manager.insert_radar_data(converted_data)
                # Busca o nome da planilha para este radar
                radar_config = next((c for c in self.radar_configs if c['id'] == radar_id), None)
                spreadsheet_name = radar_config.get('spreadsheet_name', 'N/A') if radar_config else 'N/A'
                logger.debug(f"‚úÖ [{radar_id}] Dados enviados para Google Sheets: {spreadsheet_name}")
            else:
                logger.error(f"‚ùå [{radar_id}] Gerenciador do Google Sheets n√£o encontrado")
                
        except Exception as e:
            logger.error(f"‚ùå [{radar_id}] Erro ao enviar dados: {str(e)}")

    def _check_engagement(self, section_id, distance, move_speed):
        """Verifica engajamento baseado na se√ß√£o, dist√¢ncia e velocidade"""
        if section_id is not None and distance <= 1.0 and move_speed <= 10.0:
            return True
        return False

def main():
    # Signal handler para graceful shutdown com SystemD
    def signal_handler(signum, frame):
        logger.info("üîÑ Shutdown graceful solicitado pelo SystemD")
        if 'dual_radar_manager' in locals():
            dual_radar_manager.stop()
        sys.exit(0)
    
    # Registrar handlers para SystemD (SIGTERM) e Ctrl+C (SIGINT)
    signal.signal(signal.SIGTERM, signal_handler)
    signal.signal(signal.SIGINT, signal_handler)
    
    logger.info("üöÄ Iniciando sistema de radar DUAL para SystemD...")
    
    # Cria gerenciador de radar dual
    dual_radar_manager = DualRadarManager(RADAR_CONFIGS)
    
    try:
        success = dual_radar_manager.start()
        
        if not success:
            logger.error("‚ùå Falha ao iniciar o sistema dual de radar")
            sys.exit(1)  # SystemD reinicia automaticamente
        
        # Lista portas dos radares
        radar_ports = [f"{config['id']}: {config['port']}" for config in RADAR_CONFIGS if config['port']]
        logger.info(f"‚úÖ Sistema dual iniciado - Portas: {', '.join(radar_ports)}")
        
        # Loop principal simplificado para SystemD
        while True:
            time.sleep(1)
            
            # Status a cada 60 segundos (menos verboso)
            if time.time() % 60 < 1:
                active_radars = [radar_id for radar_id, connection in dual_radar_manager.radar_connections.items() 
                               if connection and connection.is_open]
                logger.info(f"üìä Sistema dual ativo - Radares ativos: {', '.join(active_radars)}")
            
    except Exception as e:
        logger.error(f"‚ùå Erro cr√≠tico: {e}")
        sys.exit(1)  # SystemD reinicia automaticamente
        
    finally:
        dual_radar_manager.stop()
        logger.info("‚úÖ Sistema dual encerrado!")

if __name__ == "__main__":
    main() 
