# -*- coding: utf-8 -*-
"""codigo_sc_recuperacao

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TtdGhKcNlR4fn_jQGiF5gsPhIT33I5XT
"""

#!/usr/bin/env python3
"""
CONTADOR SANTA CRUZ v4.3 + AUTO-RECUPERA√á√ÉO
Sistema que resolve automaticamente problemas ap√≥s 3+ horas
"""

import gspread
from google.oauth2.service_account import Credentials
from datetime import datetime, timedelta
import logging
import os
import traceback
import time
import json
import serial
import threading
import serial.tools.list_ports
import gc
from dotenv import load_dotenv

# Configura√ß√£o b√°sica de logging com rota√ß√£o
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('santa_cruz_auto_recovery.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger('santa_cruz_auto_recovery')

# Configurando o n√≠vel de log para outros m√≥dulos
logging.getLogger('urllib3').setLevel(logging.WARNING)
logging.getLogger('gspread').setLevel(logging.WARNING)

load_dotenv()

# Configura√ß√£o do radar
RADAR_CONFIG = {
    'id': 'RADAR_1',
    'name': 'Contador de Pessoas',
    'port': '/dev/ttyACM0',
    'baudrate': 115200,
    'spreadsheet_id': '1zVVyL6D9XSrzFvtDxaGJ-3CdniD-gG3Q-bUUXyqr3D4',
    'color': 'üî¥',
    'description': 'Contador v4.3: Arduino minimal + Auto-Recovery'
}

class AutoRecoveryGoogleSheetsManager:
    """GoogleSheetsManager com auto-recupera√ß√£o integrada"""

    def __init__(self, creds_path, spreadsheet_id, radar_id):
        SCOPES = [
            'https://www.googleapis.com/auth/spreadsheets',
            'https://www.googleapis.com/auth/drive',
            'https://www.googleapis.com/auth/drive.file'
        ]
        self.radar_id = radar_id
        self.spreadsheet_id = spreadsheet_id
        self.creds_path = creds_path

        # Controle de auto-recupera√ß√£o
        self.last_successful_write = datetime.now()
        self.consecutive_failures = 0
        self.max_failures_before_recovery = 3
        self.recovery_attempts = 0
        self.max_recovery_attempts = 5

        # Conecta inicialmente
        self._connect_with_recovery()
        self._setup_headers()

    def _connect_with_recovery(self):
        """Conecta com sistema de recupera√ß√£o robusto"""
        for attempt in range(3):
            try:
                # Re-cria credenciais sempre (evita token expirado)
                SCOPES = [
                    'https://www.googleapis.com/auth/spreadsheets',
                    'https://www.googleapis.com/auth/drive',
                    'https://www.googleapis.com/auth/drive.file'
                ]
                self.creds = Credentials.from_service_account_file(self.creds_path, scopes=SCOPES)
                self.gc = gspread.authorize(self.creds)

                self.spreadsheet = self.gc.open_by_key(self.spreadsheet_id)
                self.worksheet = self.spreadsheet.get_worksheet(0)

                # Testa leitura (opera√ß√£o leve)
                headers = self.worksheet.row_values(1)

                logger.info(f"‚úÖ Google Sheets conectado (tentativa {attempt + 1})")
                self.consecutive_failures = 0
                return True

            except Exception as e:
                logger.warning(f"‚ö†Ô∏è Falha na conex√£o tentativa {attempt + 1}: {e}")
                if attempt < 2:
                    time.sleep((attempt + 1) * 5)  # Backoff

        raise Exception("Falha ao conectar ap√≥s m√∫ltiplas tentativas")

    def _setup_headers(self):
        """Configura cabe√ßalhos (com retry)"""
        try:
            headers = self.worksheet.row_values(1)
            expected_headers = [
                'radar_id', 'timestamp', 'person_count', 'person_id',
                'zone', 'distance', 'confidence', 'total_detected', 'max_simultaneous'
            ]

            if not headers or len(headers) < 9:
                logger.info("üîß Configurando cabe√ßalhos...")
                self.worksheet.clear()
                self.worksheet.append_row(expected_headers)
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Erro configurando cabe√ßalhos: {e}")

    def append_row_with_auto_recovery(self, row):
        """Envia linha com auto-recupera√ß√£o completa"""
        for attempt in range(3):
            try:
                self.worksheet.append_row(row)
                self.last_successful_write = datetime.now()
                self.consecutive_failures = 0
                return True

            except Exception as e:
                self.consecutive_failures += 1
                error_str = str(e).lower()

                logger.warning(f"‚ö†Ô∏è Erro envio (tentativa {attempt + 1}): {e}")

                # Tipos espec√≠ficos de erro
                if "quota" in error_str or "429" in error_str:
                    wait_time = (attempt + 1) * 60  # 1min, 2min, 3min
                    logger.warning(f"‚ö†Ô∏è Quota exceeded - aguardando {wait_time}s")
                    time.sleep(wait_time)

                elif "401" in error_str or "unauthorized" in error_str:
                    logger.warning("üîë Token expirado - reconectando...")
                    try:
                        self._connect_with_recovery()
                        time.sleep(2)
                    except:
                        pass

                elif "network" in error_str or "connection" in error_str:
                    logger.warning("üåê Problema de rede - aguardando...")
                    time.sleep(10 * (attempt + 1))

                else:
                    # Erro gen√©rico - tenta reconectar
                    try:
                        self._connect_with_recovery()
                        time.sleep(5)
                    except:
                        time.sleep(10)

        # Se chegou aqui, todas as tentativas falharam
        logger.error(f"‚ùå Falha total no envio ap√≥s 3 tentativas")

        # Auto-recupera√ß√£o extrema
        if self.consecutive_failures >= self.max_failures_before_recovery:
            return self._attempt_full_recovery()

        return False

    def _attempt_full_recovery(self):
        """Recupera√ß√£o completa do sistema Google Sheets"""
        if self.recovery_attempts >= self.max_recovery_attempts:
            logger.error("üö® M√°ximo de recupera√ß√µes atingido!")
            return False

        self.recovery_attempts += 1
        logger.info(f"üîÑ Recupera√ß√£o completa #{self.recovery_attempts}")

        try:
            # 1. For√ßa garbage collection
            gc.collect()

            # 2. Aguarda mais tempo
            time.sleep(30)

            # 3. Reconecta completamente
            self._connect_with_recovery()

            # 4. Testa com dados simples
            test_row = [
                self.radar_id,
                datetime.now().strftime('%d/%m/%Y %H:%M:%S'),
                0, "Recovery_Test", "RECOVERY", "0", "100", 0, 0
            ]

            self.worksheet.append_row(test_row)

            logger.info("‚úÖ Recupera√ß√£o completa bem-sucedida!")
            self.consecutive_failures = 0
            return True

        except Exception as e:
            logger.error(f"‚ùå Falha na recupera√ß√£o completa: {e}")
            return False

    def health_check(self):
        """Verifica sa√∫de da conex√£o"""
        time_since_success = datetime.now() - self.last_successful_write

        if time_since_success > timedelta(minutes=15):
            logger.warning(f"‚ö†Ô∏è Sem envios h√° {time_since_success}")
            return False

        if self.consecutive_failures > 5:
            logger.warning(f"‚ö†Ô∏è {self.consecutive_failures} falhas consecutivas")
            return False

        return True

class ZoneManager:
    """Sistema de zonas do Santa Cruz"""
    def __init__(self):
        self.ZONA_CONFIGS = {
            # LADO ESQUERDO (X < -0.3)
            'SALA_REBOCO': {
                'x_min': -3.5, 'x_max': -0.3,
                'y_min': 0.3, 'y_max': 3.8,
                'distance_range': (1.0, 4.0)
            },
            'IGREJINHA': {
                'x_min': -3.0, 'x_max': -0.2,
                'y_min': 2.8, 'y_max': 6.0,
                'distance_range': (2.5, 6.0)
            },
            # CENTRO (X entre -0.8 e 0.8)
            'CENTRO': {
                'x_min': -1.0, 'x_max': 1.0,
                'y_min': 1.0, 'y_max': 4.5,
                'distance_range': (2.0, 5.0)
            },
            # LADO DIREITO (X > 0.5)
            'ARGOLA': {
                'x_min': 0.3, 'x_max': 3.0,
                'y_min': 4.0, 'y_max': 7.5,
                'distance_range': (4.0, 8.0)
            },
            'BEIJO': {
                'x_min': 0.5, 'x_max': 3.5,
                'y_min': 2.0, 'y_max': 5.5,
                'distance_range': (3.5, 7.5)
            },
            'PESCARIA': {
                'x_min': 0.8, 'x_max': 4.0,
                'y_min': 0.2, 'y_max': 4.0,
                'distance_range': (4.0, 9.0)
            }
        }

    def get_zone(self, x, y):
        """Determinar zona baseada nas ativa√ß√µes espec√≠ficas"""
        distance = self.get_distance(x, y)

        for zona_name, config in self.ZONA_CONFIGS.items():
            if (config['x_min'] <= x <= config['x_max'] and
                config['y_min'] <= y <= config['y_max'] and
                config['distance_range'][0] <= distance <= config['distance_range'][1]):
                return zona_name

        return 'FORA_ATIVACOES'

    def get_distance(self, x, y):
        """Calcular dist√¢ncia do radar"""
        import math
        return math.sqrt(x**2 + y**2)

    def get_zone_description(self, zone_name):
        """Retorna descri√ß√£o amig√°vel da zona"""
        descriptions = {
            'SALA_REBOCO': 'Sala de Reboco',
            'IGREJINHA': 'Igrejinha',
            'CENTRO': 'Centro',
            'ARGOLA': 'Jogo da Argola',
            'BEIJO': 'Barraca do Beijo',
            'PESCARIA': 'Pescaria',
            'FORA_ATIVACOES': 'Fora das Ativa√ß√µes'
        }
        return descriptions.get(zone_name, zone_name)

class AutoRecoveryRadarCounter:
    """Contador COMPLETO com sistema de auto-recupera√ß√£o integrado"""

    def __init__(self, config):
        self.config = config
        self.radar_id = config['id']
        self.radar_name = config['name']
        self.port = config['port']
        self.baudrate = config['baudrate']
        self.color = config['color']
        self.description = config['description']

        # Sistema de auto-recupera√ß√£o
        self.start_time = datetime.now()
        self.last_data_received = datetime.now()
        self.last_sheets_success = datetime.now()
        self.system_restart_count = 0
        self.max_system_restarts = 3

        # Estado do radar
        self.serial_connection = None
        self.is_running = False
        self.receive_thread = None
        self.gsheets_manager = None
        self.zone_manager = ZoneManager()  # ‚úÖ ADICIONADO

        # ‚úÖ SISTEMA COMPLETO DE CONTAGEM (igual ao original)
        self.current_people = {}
        self.previous_people = {}
        self.people_history = {}
        self.total_people_detected = 0
        self.max_simultaneous_people = 0
        self.session_start_time = datetime.now()

        # Configura√ß√µes de tracking
        self.exit_timeout = 3.0
        self.reentry_timeout = 10.0
        self.last_update_time = time.time()

        # Configura√ß√µes anti-quota
        self.last_sheets_write = 0
        self.sheets_write_interval = 30.0
        self.pending_data = []

        # ‚úÖ ESTAT√çSTICAS DETALHADAS (igual ao original)
        self.entries_count = 0
        self.exits_count = 0
        self.unique_people_today = set()

        # Thread de monitoramento
        self.monitoring_thread = None

    def start_health_monitoring(self):
        """Inicia monitoramento de sa√∫de em background"""
        self.monitoring_thread = threading.Thread(target=self._health_monitoring_loop, daemon=True)
        self.monitoring_thread.start()
        logger.info("üîÑ Monitoramento de sa√∫de iniciado")

    def _health_monitoring_loop(self):
        """Loop de monitoramento de sa√∫de"""
        while self.is_running:
            try:
                time.sleep(60)  # Verifica a cada minuto
                self._check_system_health()
            except Exception as e:
                logger.error(f"‚ùå Erro no monitoramento: {e}")
                time.sleep(30)

    def _check_system_health(self):
        """Verifica sa√∫de geral do sistema"""
        now = datetime.now()

        # 1. Verifica recebimento de dados serial
        time_since_data = now - self.last_data_received
        if time_since_data > timedelta(minutes=5):
            logger.warning(f"‚ö†Ô∏è Sem dados seriais h√° {time_since_data}")
            self._attempt_serial_recovery()

        # 2. Verifica envios para planilha
        time_since_sheets = now - self.last_sheets_success
        if time_since_sheets > timedelta(minutes=10):
            logger.warning(f"‚ö†Ô∏è Sem envios h√° {time_since_sheets}")
            if self.gsheets_manager:
                self.gsheets_manager._attempt_full_recovery()

        # 3. Verifica uso de mem√≥ria
        try:
            import psutil
            process = psutil.Process()
            memory_mb = process.memory_info().rss / 1024 / 1024

            if memory_mb > 200:  # 200MB limite
                logger.warning(f"‚ö†Ô∏è Mem√≥ria alta: {memory_mb:.1f}MB")
                self._cleanup_memory()

        except ImportError:
            pass  # psutil n√£o dispon√≠vel
        except Exception as e:
            logger.debug(f"Erro verificando mem√≥ria: {e}")

        # 4. Restart preventivo ap√≥s 6 horas
        runtime = now - self.start_time
        if runtime > timedelta(hours=6):
            logger.info(f"‚è∞ Runtime {runtime} - restart preventivo recomendado")
            self._attempt_system_restart()

    def _cleanup_memory(self):
        """Limpa mem√≥ria e buffers"""
        try:
            # Limpa buffer de dados pendentes
            if len(self.pending_data) > 20:
                self.pending_data = self.pending_data[-10:]
                logger.info("üßπ Buffer limpo")

            # For√ßa garbage collection
            gc.collect()

        except Exception as e:
            logger.error(f"‚ùå Erro limpando mem√≥ria: {e}")

    def _attempt_serial_recovery(self):
        """Tenta recuperar conex√£o serial"""
        try:
            logger.info("üîÑ Tentando recuperar conex√£o serial...")

            # Fecha conex√£o atual
            if self.serial_connection:
                try:
                    self.serial_connection.close()
                except:
                    pass
                time.sleep(2)

            # Tenta reconectar
            if self.connect():
                logger.info("‚úÖ Conex√£o serial recuperada!")
                return True
            else:
                logger.error("‚ùå Falha na recupera√ß√£o serial")
                return False

        except Exception as e:
            logger.error(f"‚ùå Erro na recupera√ß√£o serial: {e}")
            return False

    def _attempt_system_restart(self):
        """Restart preventivo do sistema"""
        if self.system_restart_count >= self.max_system_restarts:
            logger.error("üö® M√°ximo de restarts atingido")
            return False

        self.system_restart_count += 1
        logger.info(f"üîÑ Restart preventivo #{self.system_restart_count}")

        try:
            # Para sistema
            self.stop()
            time.sleep(5)

            # Re-inicializa
            self.start(self.gsheets_manager)

            # Reset contadores
            self.start_time = datetime.now()

            logger.info("‚úÖ Restart preventivo conclu√≠do")
            return True

        except Exception as e:
            logger.error(f"‚ùå Falha no restart preventivo: {e}")
            return False

    def connect(self):
        """Conecta √† porta serial (vers√£o original)"""
        max_attempts = 3

        for attempt in range(max_attempts):
            try:
                if not os.path.exists(self.port):
                    logger.warning(f"Porta {self.port} n√£o existe, detectando...")
                    detected_port = self.find_serial_port()
                    if detected_port:
                        self.port = detected_port
                    else:
                        logger.error(f"Tentativa {attempt + 1}: Nenhuma porta encontrada")
                        time.sleep(2)
                        continue

                if hasattr(self, 'serial_connection') and self.serial_connection:
                    try:
                        self.serial_connection.close()
                    except:
                        pass

                logger.info(f"Tentativa {attempt + 1}: Conectando √† porta {self.port}")

                self.serial_connection = serial.Serial(
                    port=self.port,
                    baudrate=self.baudrate,
                    timeout=2,
                    write_timeout=2,
                    bytesize=serial.EIGHTBITS,
                    parity=serial.PARITY_NONE,
                    stopbits=serial.STOPBITS_ONE
                )

                time.sleep(3)

                if self.serial_connection.is_open:
                    logger.info(f"‚úÖ Conex√£o estabelecida com sucesso!")
                    return True

            except serial.SerialException as e:
                logger.error(f"‚ùå Erro serial na tentativa {attempt + 1}: {str(e)}")
            except Exception as e:
                logger.error(f"‚ùå Erro geral na tentativa {attempt + 1}: {str(e)}")

            if attempt < max_attempts - 1:
                wait_time = (attempt + 1) * 2
                logger.info(f"‚è≥ Aguardando {wait_time}s...")
                time.sleep(wait_time)

        logger.error(f"‚ùå Falha ao conectar ap√≥s {max_attempts} tentativas")
        return False

    def find_serial_port(self):
        """Detecta porta serial automaticamente"""
        ports = list(serial.tools.list_ports.comports())
        if not ports:
            return None

        # Primeiro tenta a porta configurada
        for port in ports:
            if port.device == self.port:
                return self.port

        # Se n√£o encontrou, procura por dispositivos apropriados
        for port in ports:
            desc_lower = port.description.lower()
            if any(term in desc_lower for term in
                  ['usb', 'serial', 'uart', 'cp210', 'ch340', 'ft232', 'arduino', 'esp32']):
                logger.warning(f"Porta {self.port} n√£o encontrada, tentando usar {port.device}")
                return port.device

        return None

    def start(self, gsheets_manager):
        """Inicia o radar com auto-recupera√ß√£o"""
        self.gsheets_manager = gsheets_manager

        if not self.connect():
            return False

        self.is_running = True
        self.receive_thread = threading.Thread(target=self.receive_data_loop, daemon=True)
        self.receive_thread.start()

        # Inicia monitoramento de sa√∫de
        self.start_health_monitoring()

        logger.info(f"üöÄ Radar com auto-recupera√ß√£o iniciado!")
        return True

    def stop(self):
        """Para o radar"""
        self.is_running = False

        if self.serial_connection:
            try:
                self.serial_connection.close()
            except:
                pass

        if self.receive_thread and self.receive_thread.is_alive():
            self.receive_thread.join(timeout=2)

        logger.info("üõë Radar parado!")

    def receive_data_loop(self):
        """Loop de dados com auto-recupera√ß√£o"""
        buffer = ""
        consecutive_errors = 0
        max_consecutive_errors = 5

        while self.is_running:
            try:
                if not self.serial_connection or not self.serial_connection.is_open:
                    logger.warning("‚ö†Ô∏è Conex√£o perdida, tentando reconectar...")
                    if self.connect():
                        consecutive_errors = 0
                        buffer = ""
                        continue
                    else:
                        consecutive_errors += 1
                        time.sleep(5)
                        continue

                in_waiting = self.serial_connection.in_waiting or 0
                data = self.serial_connection.read(in_waiting or 1)

                if data:
                    consecutive_errors = 0
                    self.last_data_received = datetime.now()  # Marca recebimento

                    text = data.decode('utf-8', errors='ignore')
                    buffer += text

                    if '\n' in buffer:
                        lines = buffer.split('\n')
                        buffer = lines[-1]

                        for line in lines[:-1]:
                            line = line.strip()
                            if not line or not line.startswith('{'):
                                continue

                            try:
                                data_json = json.loads(line)
                                self.process_json_data(data_json)
                            except json.JSONDecodeError:
                                logger.debug(f"JSON inv√°lido: {line[:50]}...")
                            except Exception as e:
                                logger.error(f"Erro processando JSON: {e}")

                time.sleep(0.01)

            except Exception as e:
                consecutive_errors += 1
                logger.error(f"‚ùå Erro no loop: {str(e)}")
                time.sleep(2)

                if consecutive_errors >= max_consecutive_errors:
                    logger.warning("‚ö†Ô∏è Muitos erros - pausando...")
                    time.sleep(10)
                    consecutive_errors = 0

    def convert_timestamp(self, timestamp_ms):
        """Converte timestamp para formato brasileiro"""
        try:
            dt = datetime.now()
            return dt.strftime('%d/%m/%Y %H:%M:%S')
        except Exception as e:
            logger.debug(f"Erro na convers√£o de timestamp: {e}")
            return datetime.now().strftime('%d/%m/%Y %H:%M:%S')

    def format_duration(self, duration_ms):
        """Formata dura√ß√£o em milissegundos para formato leg√≠vel"""
        try:
            if duration_ms < 1000:
                return f"{int(duration_ms)}ms"
            elif duration_ms < 60000:
                seconds = duration_ms / 1000
                return f"{seconds:.1f}s"
            elif duration_ms < 3600000:
                minutes = duration_ms / 60000
                return f"{minutes:.1f}min"
            else:
                hours = duration_ms / 3600000
                return f"{hours:.1f}h"
        except:
            return "N/A"

    def update_people_count(self, person_count, active_people):
        """Sistema COMPLETO de tracking (igual ao original + auto-recovery)"""
        current_time = time.time()

        # Cria IDs √∫nicos baseados em posi√ß√£o est√°vel
        current_people_dict = {}

        for i, person in enumerate(active_people):
            x_pos = person.get('x_pos', 0)
            y_pos = person.get('y_pos', 0)
            distance = person.get('distance_raw', 0)

            # ‚úÖ CALCULA ZONA ESPEC√çFICA usando coordenadas x,y
            zone = self.zone_manager.get_zone(x_pos, y_pos)
            person["zone"] = zone

            # ID baseado na posi√ß√£o arredondada (est√°vel)
            stable_id = f"P_{zone}_{distance:.1f}_{i}"

            # Procura se j√° existe pessoa similar
            found_existing = None
            for existing_id, existing_person in self.current_people.items():
                existing_dist = existing_person.get('distance_raw', 0)
                existing_zone = existing_person.get('zone', '')

                if (existing_zone == zone and
                    abs(existing_dist - distance) < 0.3):
                    found_existing = existing_id
                    break

            if found_existing:
                current_people_dict[found_existing] = person
                current_people_dict[found_existing]['last_seen'] = current_time
            else:
                # Nova pessoa detectada
                person['first_seen'] = current_time
                person['last_seen'] = current_time
                person['distance_smoothed'] = distance
                person['confidence'] = 85
                person['stationary'] = False
                current_people_dict[stable_id] = person

        # Detecta ENTRADAS REAIS
        new_entries = []
        for person_id, person_info in current_people_dict.items():
            if person_id not in self.current_people:
                is_really_new = True
                for old_id, old_person in self.previous_people.items():
                    old_zone = old_person.get('zone', '')
                    old_dist = old_person.get('distance_raw', 0)
                    new_zone = person_info.get('zone', '')
                    new_dist = person_info.get('distance_raw', 0)

                    if (old_zone == new_zone and
                        abs(old_dist - new_dist) < 0.5 and
                        (current_time - old_person.get('last_seen', 0)) < 2.0):
                        is_really_new = False
                        break

                if is_really_new:
                    new_entries.append(person_id)
                    self.total_people_detected += 1
                    self.entries_count += 1
                    self.unique_people_today.add(person_id)
                    zone = person_info.get('zone', 'DESCONHECIDA')
                    dist = person_info.get('distance_raw', 0)
                    logger.info(f"üÜï ENTRADA REAL: {zone} {dist:.1f}m (Total: {self.total_people_detected})")

        # Detecta SA√çDAS REAIS
        exits = []
        for person_id, person_info in self.current_people.items():
            if person_id not in current_people_dict:
                last_seen = person_info.get('last_seen', 0)
                if (current_time - last_seen) > 1.0:
                    exits.append(person_id)
                    self.exits_count += 1
                    zone = person_info.get('zone', 'DESCONHECIDA')
                    dist = person_info.get('distance_raw', 0)
                    logger.info(f"üö™ SA√çDA REAL: {zone} {dist:.1f}m (Entradas: {self.entries_count}, Sa√≠das: {self.exits_count})")

        # Atualiza estado
        self.previous_people = self.current_people.copy()
        self.current_people = current_people_dict

        # Atualiza m√°ximo simult√¢neo
        current_simultaneous = len(current_people_dict)
        if current_simultaneous > self.max_simultaneous_people:
            self.max_simultaneous_people = current_simultaneous
            logger.info(f"üìä NOVO M√ÅXIMO SIMULT√ÇNEO: {self.max_simultaneous_people} pessoas")

        # Log apenas se houve mudan√ßas reais
        if new_entries or exits:
            logger.info(f"üìä STATUS: {current_simultaneous} ativas | {self.total_people_detected} total | M√°x: {self.max_simultaneous_people}")

        self.last_update_time = current_time

    def process_json_data(self, data_json):
        """Processa dados JSON COMPLETO (igual ao original + auto-recovery)"""
        try:
            radar_id = data_json.get("radar_id", self.radar_id)
            timestamp_ms = data_json.get("timestamp_ms", 0)
            person_count = data_json.get("person_count", 0)
            active_people = data_json.get("active_people", [])
            tracking_method = data_json.get("tracking_method", "hybrid_multi")
            session_duration_ms = data_json.get("session_duration_ms", 0)
            update_rate_hz = data_json.get("update_rate_hz", 8.3)

            # Converte timestamp para formato leg√≠vel
            formatted_timestamp = self.convert_timestamp(timestamp_ms)

            # Atualiza contadores locais com l√≥gica COMPLETA
            self.update_people_count(person_count, active_people)

            # ‚úÖ DISPLAY COMPLETO (igual ao original)
            os.system('clear')
            print(f"\n{self.color} ‚ïê‚ïê‚ïê CONTADOR ROBUSTO + AUTO-RECOVERY ‚ïê‚ïê‚ïê")
            print(f"‚è∞ {formatted_timestamp}")
            print(f"üì° {radar_id} | üë• ATIVAS: {person_count}")
            print(f"üéØ TOTAL DETECTADAS: {self.total_people_detected} | üìä M√ÅXIMO SIMULT√ÇNEO: {self.max_simultaneous_people}")
            print(f"üîÑ ENTRADAS: {self.entries_count} | üö™ SA√çDAS: {self.exits_count}")
            print(f"üÜî PESSOAS √öNICAS: {len(self.unique_people_today)}")

            # ‚úÖ STATUS AUTO-RECOVERY
            runtime = datetime.now() - self.start_time
            time_since_sheets = datetime.now() - self.last_sheets_success
            duration_str = self.format_duration(runtime.total_seconds() * 1000)
            print(f"‚è±Ô∏è SESS√ÉO: {duration_str} | üîÑ Restarts: {self.system_restart_count}")

            # Status do envio para planilha
            pending_count = len(self.pending_data)
            time_since_last_send = time.time() - self.last_sheets_write
            next_send_in = max(0, self.sheets_write_interval - time_since_last_send)
            if pending_count > 0:
                print(f"üìã BUFFER: {pending_count} linhas | ‚è≥ Pr√≥ximo envio em: {next_send_in:.0f}s")
            else:
                print(f"üìã PLANILHA: Sincronizada ‚úÖ | √öltimo envio: {time_since_sheets}")

            if active_people and len(active_people) > 0:
                print(f"\nüë• PESSOAS DETECTADAS AGORA ({len(active_people)}):")
                print(f"{'Ativa√ß√£o':<15} {'Dist(m)':<7} {'X,Y':<10} {'Conf%':<5} {'Status':<8} {'Desde':<8}")
                print("-" * 65)

                current_time = time.time()
                for i, person in enumerate(active_people):
                    confidence = person.get("confidence", 85)
                    distance_raw = person.get("distance_raw", 0)
                    distance_smoothed = person.get("distance_smoothed", distance_raw)
                    x_pos = person.get("x_pos", 0)
                    y_pos = person.get("y_pos", 0)
                    stationary = person.get("stationary", False)

                    # ‚úÖ CALCULA ZONA usando coordenadas x,y
                    zone = self.zone_manager.get_zone(x_pos, y_pos)
                    person["zone"] = zone

                    # Encontra ID da nossa l√≥gica interna
                    our_person_id = None
                    for internal_id, internal_person in self.current_people.items():
                        internal_dist = internal_person.get('distance_raw', internal_person.get('distance_smoothed', 0))
                        if (abs(internal_dist - distance_raw) < 0.1 and
                            internal_person.get('zone', '') == zone):
                            our_person_id = internal_id
                            break

                    # Calcula tempo desde primeira detec√ß√£o
                    if our_person_id and our_person_id in self.current_people:
                        first_seen = self.current_people[our_person_id].get('first_seen', current_time)
                        time_in_area = current_time - first_seen
                        time_str = f"{time_in_area:.0f}s" if time_in_area < 60 else f"{time_in_area/60:.1f}m"
                    else:
                        time_str = "novo"

                    status = "Parado" if stationary else "M√≥vel"
                    pos_str = f"{x_pos:.1f},{y_pos:.1f}"

                    zone_desc = self.zone_manager.get_zone_description(zone)[:14]
                    print(f"{zone_desc:<15} {distance_raw:<7.2f} {pos_str:<10} {confidence:<5}% {status:<8} {time_str:<8}")

                # ‚úÖ ENVIA DADOS COMPLETOS
                if self.gsheets_manager:
                    avg_confidence = sum(p.get("confidence", 0) for p in active_people) / len(active_people)
                    zones_detected = list(set(p.get("zone", "N/A") for p in active_people))
                    zones_str = ",".join(sorted(zones_detected))

                    if len(active_people) == 1:
                        person_description = "Pessoa Individual"
                    elif len(active_people) <= 3:
                        person_description = "Grupo Pequeno"
                    elif len(active_people) <= 10:
                        person_description = "Grupo M√©dio"
                    elif len(active_people) <= 20:
                        person_description = "Grupo Grande"
                    else:
                        person_description = "Multid√£o"

                    row = [
                        radar_id,
                        formatted_timestamp,
                        len(active_people),
                        person_description,
                        zones_str,
                        f"{sum(p.get('distance_raw', p.get('distance_smoothed', 0)) for p in active_people) / len(active_people):.1f}",
                        f"{avg_confidence:.0f}",
                        self.total_people_detected,
                        self.max_simultaneous_people
                    ]
                    self.pending_data.append(row)

                print(f"\nüí° DETECTANDO {len(active_people)} pessoa(s) SIMULTANEAMENTE")

                # ‚úÖ ESTAT√çSTICAS POR ZONA
                zone_stats = {}
                high_confidence = 0
                for person in active_people:
                    zone = person.get("zone", "N/A")
                    zone_stats[zone] = zone_stats.get(zone, 0) + 1
                    if person.get("confidence", 0) >= 70:
                        high_confidence += 1

                if zone_stats:
                    print("üìä DISTRIBUI√á√ÉO POR ATIVA√á√ÉO:")
                    for zone, count in zone_stats.items():
                        zone_desc = self.zone_manager.get_zone_description(zone)
                        print(f"   ‚Ä¢ {zone_desc}: {count} pessoa(s)")
                    print()

                print(f"‚úÖ QUALIDADE: {high_confidence}/{len(active_people)} com alta confian√ßa (‚â•70%)")

            else:
                print(f"\nüëª Nenhuma pessoa detectada no momento.")

                # Envia dados zerados apenas se houve mudan√ßa
                if self.gsheets_manager and len(self.previous_people) > 0:
                    row = [
                        radar_id, formatted_timestamp, 0, "Area_Vazia", "VAZIA",
                        "0", "0", self.total_people_detected, self.max_simultaneous_people
                    ]
                    self.pending_data.append(row)

            print("\n" + "=" * 60)
            print("üéØ SISTEMA ROBUSTO + AUTO-RECOVERY ATIVO")
            print("‚úÖ Tracking preciso | ‚úÖ Auto-reconex√£o | ‚úÖ Anti-quota")
            print("‚ö° Pressione Ctrl+C para encerrar")

            # ‚úÖ ENVIA COM AUTO-RECOVERY
            self.send_pending_data_with_recovery()

        except Exception as e:
            logger.error(f"Erro ao processar dados JSON: {e}")
            logger.debug(f"JSON recebido: {data_json}")

    def send_pending_data_with_recovery(self):
        """Envia dados com sistema de auto-recupera√ß√£o"""
        current_time = time.time()

        if (current_time - self.last_sheets_write) < self.sheets_write_interval:
            return

        if not self.pending_data or not self.gsheets_manager:
            return

        data_to_send = self.pending_data[-5:]  # M√°ximo 5 linhas por vez

        try:
            for row in data_to_send:
                success = self.gsheets_manager.append_row_with_auto_recovery(row)
                if success:
                    self.last_sheets_success = datetime.now()
                time.sleep(0.5)

            if data_to_send:
                logger.info(f"üìä {len(data_to_send)} linhas enviadas com auto-recovery")
                self.last_sheets_write = current_time
                self.pending_data = []

        except Exception as e:
            logger.error(f"‚ùå Erro no envio com recovery: {e}")

    def get_current_count(self):
        """Retorna o √∫ltimo person_count recebido"""
        return len(self.current_people)

    def get_total_detected(self):
        """Retorna total de pessoas detectadas na sess√£o"""
        return self.total_people_detected

    def get_status(self):
        """Retorna status completo do radar com estat√≠sticas robustas"""
        return {
            'id': self.radar_id,
            'name': self.radar_name,
            'port': self.port,
            'running': self.is_running,
            'connected': self.serial_connection and self.serial_connection.is_open if self.serial_connection else False,
            'description': self.description,
            'current_count': self.get_current_count(),
            'total_detected': self.get_total_detected(),
            'max_simultaneous': self.max_simultaneous_people,
            'entries_count': self.entries_count,
            'exits_count': self.exits_count,
            'unique_people': len(self.unique_people_today),
            'people_in_area': len(self.current_people),
            'session_duration': (datetime.now() - self.session_start_time).total_seconds(),
            'system_restarts': self.system_restart_count,
            'health_status': 'healthy' if datetime.now() - self.last_data_received < timedelta(minutes=5) else 'unhealthy'
        }

def main():
    """Fun√ß√£o principal com auto-recupera√ß√£o"""
    logger.info("üöÄ Iniciando Contador com Auto-Recupera√ß√£o...")

    # Configura Google Sheets com auto-recovery
    script_dir = os.path.dirname(os.path.abspath(__file__))
    credentials_file = os.path.join(script_dir, 'serial_radar', 'credenciais.json')

    if not os.path.exists(credentials_file):
        logger.error(f"‚ùå Credenciais n√£o encontradas: {credentials_file}")
        return

    try:
        gsheets_manager = AutoRecoveryGoogleSheetsManager(
            credentials_file,
            RADAR_CONFIG['spreadsheet_id'],
            RADAR_CONFIG['id']
        )
        logger.info("‚úÖ Google Sheets com auto-recovery configurado")
    except Exception as e:
        logger.error(f"‚ùå Erro configurando Sheets: {e}")
        return

    # Inicializa radar com auto-recovery
    radar = AutoRecoveryRadarCounter(RADAR_CONFIG)

    try:
        if not radar.start(gsheets_manager):
            logger.error("‚ùå Falha ao iniciar radar")
            return

        # Exibe status inicial completo
        status = radar.get_status()
        logger.info("=" * 80)
        logger.info("üë• CONTADOR SANTA CRUZ v4.3 + AUTO-RECOVERY COMPLETO")
        logger.info("=" * 80)
        logger.info(f"üî¥ {status['name']}: {status['port']}")
        logger.info(f"üìã {status['description']}")
        logger.info("üöÄ FUNCIONALIDADES INTEGRADAS:")
        logger.info("   ‚úÖ Sistema completo de tracking de pessoas (igual ao original)")
        logger.info("   ‚úÖ Detec√ß√£o de zonas das ativa√ß√µes (6 ativa√ß√µes espec√≠ficas)")
        logger.info("   ‚úÖ L√≥gica robusta de entrada/sa√≠da (anti-flickering)")
        logger.info("   ‚úÖ Display detalhado em tempo real")
        logger.info("   ‚úÖ Estat√≠sticas por zona")
        logger.info("   ‚úÖ Auto-reconex√£o serial inteligente")
        logger.info("   ‚úÖ Auto-recupera√ß√£o Google Sheets com retry")
        logger.info("   ‚úÖ Monitoramento de sa√∫de em background")
        logger.info("   ‚úÖ Restart preventivo ap√≥s 6 horas")
        logger.info("   ‚úÖ Limpeza de mem√≥ria autom√°tica")
        logger.info("   ‚úÖ Anti-quota inteligente (30s intervalo)")
        logger.info("   ‚úÖ Controle de token expirado")
        logger.info("üéØ RESOLU√á√ÉO DO PROBLEMA DE 3+ HORAS:")
        logger.info("   ‚Ä¢ Token expirado ‚ûú Renova√ß√£o autom√°tica")
        logger.info("   ‚Ä¢ Quota exceeded ‚ûú Backoff inteligente")
        logger.info("   ‚Ä¢ Conex√£o serial perdida ‚ûú Reconex√£o autom√°tica")
        logger.info("   ‚Ä¢ Mem√≥ria alta ‚ûú Limpeza autom√°tica")
        logger.info("   ‚Ä¢ Sistema travado ‚ûú Restart preventivo")
        logger.info("‚ö° Sistema H√çBRIDO: Funcionalidades completas + Auto-recovery")
        logger.info("üîÑ Reconex√£o autom√°tica habilitada para todos os componentes")
        logger.info("=" * 80)

        # Loop principal melhorado
        status_counter = 0
        while True:
            time.sleep(5)  # Verifica a cada 5 segundos
            status_counter += 1

            # Status detalhado a cada 30 segundos (6 * 5s = 30s)
            if status_counter >= 6:
                status_counter = 0
                status = radar.get_status()
                current_count = status['people_in_area']
                total_detected = status['total_detected']
                max_simultaneous = status['max_simultaneous']
                entries = status['entries_count']
                exits = status['exits_count']
                unique_people = status['unique_people']
                restarts = status['system_restarts']
                health = status['health_status']

                # Status baseado na sa√∫de do sistema
                if health == 'healthy' and radar.is_running and radar.serial_connection and radar.serial_connection.is_open:
                    logger.info(f"üíö SAUD√ÅVEL: {current_count} ativas | {total_detected} total | {entries} entradas | {exits} sa√≠das | {unique_people} √∫nicas | M√°x: {max_simultaneous} | Restarts: {restarts}")
                elif radar.is_running:
                    logger.warning(f"üíõ PROBLEMAS: Radar rodando mas conex√£o inst√°vel - tentando auto-recovery...")
                else:
                    logger.error(f"‚ùå CR√çTICO: Radar n√£o est√° ativo - sistema parado")

                # Verifica sa√∫de do Google Sheets
                if gsheets_manager.health_check():
                    logger.info(f"üìä PLANILHA: Funcionando normalmente")
                else:
                    logger.warning(f"üìä PLANILHA: Problemas detectados - executando auto-recovery...")

    except KeyboardInterrupt:
        logger.info("üõë Encerrando por solicita√ß√£o do usu√°rio...")

    except Exception as e:
        logger.error(f"‚ùå Erro inesperado: {str(e)}")
        logger.error(traceback.format_exc())

    finally:
        radar.stop()
        logger.info("‚úÖ Sistema encerrado!")

if __name__ == "__main__":
    main()